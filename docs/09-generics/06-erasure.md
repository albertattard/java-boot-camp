---
layout: default
title: Type Erasure
parent: Generics
nav_order: 6
permalink: docs/generics/erasure/
---

# Type Erasure
{: .no_toc }

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## What is type erasure?

[Generics](https://jcp.org/en/jsr/detail?id=14) came late to the language (in Java 1.5) and were implemented in a way that it is still compatible to code that does not use generics ([raw types]({{ '/docs/generics/raw-types/' | absolute_url }})).  There are cases were we need to use raw types as the generic information is not present at runtime, as we will discuss [later on](#are-there-cases-where-we-cannot-use-generics).

[Type Erasure](https://docs.oracle.com/javase/tutorial/java/generics/erasure.html) is the process that happens at compile time and making sure that our code works as expected and is also backward compatible while also providing us with compile time errors.  Type erasure performs three things:

* Replace all type parameters in generic types with their upper bounds.  The generic type `T` is replaced by the upper bound if one is defined or `Object`.
* Insert type casts if necessary, to preserve type safety.
* Generate bridge methods to preserve polymorphism in extended generic types.

Each aspect of type erasure is explored in more details in the following sections.

## How are type parameters replaced?

Consider the following example.

```java
package demo;

public class Box<T> {

  private T item;

  public void put( final T item ) {
    this.item = item;
  }
}
```

The `Box` class is a generic type that has one type parameter, `T`.  It has one method that takes a parameter of type `T` and stores this in the property named `item`.  `T` is not a type that the Java runtime can work with, thus the compiler will have to replace this with an `Object`.

The generated bytecode shows how the class will look after it is compiled (_View > Show Bytecode_)

```
// class version 58.65535 (-65478)
// access flags 0x21
// signature <T:Ljava/lang/Object;>Ljava/lang/Object;
// declaration: demo/Box<T>
public class demo/Box {

  // compiled from: Box.java

  // access flags 0x2
  // signature TT;
  // declaration: item extends T
  private Ljava/lang/Object; item

  // access flags 0x1
  public <init>()V
   L0
    LINENUMBER 3 L0
    ALOAD 0
    INVOKESPECIAL java/lang/Object.<init> ()V
    RETURN
   L1
    LOCALVARIABLE this Ldemo/Box; L0 L1 0
    // signature Ldemo/Box<TT;>;
    // declaration: this extends demo.Box<T>
    MAXSTACK = 1
    MAXLOCALS = 1

  // access flags 0x1
  // signature (TT;)V
  // declaration: void put(T)
  public put(Ljava/lang/Object;)V
   L0
    LINENUMBER 8 L0
    ALOAD 0
    ALOAD 1
    PUTFIELD demo/Box.item : Ljava/lang/Object;
   L1
    LINENUMBER 9 L1
    RETURN
   L2
    LOCALVARIABLE this Ldemo/Box; L0 L2 0
    // signature Ldemo/Box<TT;>;
    // declaration: this extends demo.Box<T>
    LOCALVARIABLE item Ljava/lang/Object; L0 L2 1
    // signature TT;
    // declaration: item extends T
    MAXSTACK = 2
    MAXLOCALS = 2
}
```

Let's break the bytecode shown above into smaller pieces.

1. Our `Box` class has one property and is of type `Object`

   ```java
     private T item;
   ```

   The bytecode for the above property.

   ```
     // access flags 0x2
     // signature TT;
     // declaration: item extends T
     private Ljava/lang/Object; item
   ```

   The Java compiler has one `Box` class which can contain any type.  We can create a box of type `String` or of type `Double`.  Yet we have only one class defined.  To accommodate all possible types, Java has to store our value in a property of type `Object`.

   {% include custom/note.html details="This may be a hint to you why generics do not support primitives.  The compiler replaces the type parameter from <code>T</code> to an <code>Object</code>." %}

1. The generic `put()` method takes one parameter of type `T`

   ```java
     public void put( final T item ) {
       this.item = item;
     }
   ```

   The bytecode for the above method.

   ```
     // access flags 0x1
     // signature (TT;)V
     // declaration: void put(T)
     public put(Ljava/lang/Object;)V
      L0
       LINENUMBER 8 L0
       ALOAD 0
       ALOAD 1
       PUTFIELD demo/Box.item : Ljava/lang/Object;
      L1
       LINENUMBER 9 L1
       RETURN
      L2
       LOCALVARIABLE this Ldemo/Box; L0 L2 0
       // signature Ldemo/Box<TT;>;
       // declaration: this extends demo.Box<T>
       LOCALVARIABLE item Ljava/lang/Object; L0 L2 1
       // signature TT;
       // declaration: item extends T
       MAXSTACK = 2
       MAXLOCALS = 2
   ```

   The method parameter is changed from `T` to `Object` as shown in the above bytecode.

### Are all type parameters changed from type parameter, `T`, to `Object`?

**No**.

Type erasure replaces the type parameter to its upper bound.  Consider the `Box` example that we discussed before.

```java
package demo;

public class Box<T> {

  private T item;

  public void put( final T item ) {
    this.item = item;
  }
}
```

The type parameter `T` can be any object as we are not providing an upper bound.  We can write the above example as shown next.

```java
package demo;

public class Box<T extends Object> { /* ... */ }
```

Both generic definitions are equivalent.  We can restrict the type parameter to be of a type we need.  Consider the following interface.

```java
package demo;

public interface BoxItem {
}
```

We can use the above interface (or any type that can be extended) to limit the types that we can use together with the `Box` generic type, thus specifying an upper bound, as shown next.

```java
package demo;

public class Box<T extends BoxItem> { /* ... */ }
```

If we build these two classes and view the `Box`'s class bytecode (_View > Show Bytecode_) we will see that the compiler has now replaced our type parameter `T` by the `BoxItem` type, as shown next.

```
// class version 58.65535 (-65478)
// access flags 0x21
// signature <T::Ldemo/BoxItem;>Ljava/lang/Object;
// declaration: demo/Box<T extends demo.BoxItem>
public class demo/Box {

  // compiled from: Box.java

  // access flags 0x2
  // signature TT;
  // declaration: item extends T
  private Ldemo/BoxItem; item

  // access flags 0x1
  public <init>()V
   L0
    LINENUMBER 3 L0
    ALOAD 0
    INVOKESPECIAL java/lang/Object.<init> ()V
    RETURN
   L1
    LOCALVARIABLE this Ldemo/Box; L0 L1 0
    // signature Ldemo/Box<TT;>;
    // declaration: this extends demo.Box<T>
    MAXSTACK = 1
    MAXLOCALS = 1

  // access flags 0x1
  // signature (TT;)V
  // declaration: void put(T)
  public put(Ldemo/BoxItem;)V
   L0
    LINENUMBER 8 L0
    ALOAD 0
    ALOAD 1
    PUTFIELD demo/Box.item : Ldemo/BoxItem;
   L1
    LINENUMBER 9 L1
    RETURN
   L2
    LOCALVARIABLE this Ldemo/Box; L0 L2 0
    // signature Ldemo/Box<TT;>;
    // declaration: this extends demo.Box<T>
    LOCALVARIABLE item Ldemo/BoxItem; L0 L2 1
    // signature TT;
    // declaration: item extends T
    MAXSTACK = 2
    MAXLOCALS = 2
}
```

Following are the two parts that we effected by our change.

1. The property is now of type `BoxItem`

   ```
     // access flags 0x2
     // signature TT;
     // declaration: item extends T
     private Ldemo/BoxItem; item
   ```

1. The `put()` method's parameter is now of type `BoxItem`

   ```
     // access flags 0x1
     // signature (TT;)V
     // declaration: void put(T)
     public put(Ldemo/BoxItem;)V
      L0
       LINENUMBER 8 L0
       ALOAD 0
       ALOAD 1
       PUTFIELD demo/Box.item : Ldemo/BoxItem;
      L1
       LINENUMBER 9 L1
       RETURN
      L2
       LOCALVARIABLE this Ldemo/Box; L0 L2 0
       // signature Ldemo/Box<TT;>;
       // declaration: this extends demo.Box<T>
       LOCALVARIABLE item Ldemo/BoxItem; L0 L2 1
       // signature TT;
       // declaration: item extends T
       MAXSTACK = 2
       MAXLOCALS = 2
   ```

## What are bridge methods and why are these needed?

Consider our generic `Box` class, shown below.

```java
package demo;

public class Box<T> {

  private T item;

  public void put( final T item ) {
    this.item = item;
  }
}
```

When our generic class is compiled, the type parameter `T` is replaced by the `Object` type, as we saw [before](#how-are-type-parameters-replaced).  Our code will look like the following.

{% include custom/note.html details="The following is an example of how the code will look like after type erasure."%}

```
package demo;

public class Box {

  private Object item;

  public void put( final Object item ) {
    this.item = item;
  }
}
```

Now consider the following `StringBox` class, that extends our generic type `Box`.

```java
package demo;

public class StringBox extends Box<String> {
  @Override
  public void put( final String item ) {
    System.out.printf( "Adding string: %s%n", item );
    super.put( item );
  }
}
```

After type erasure, the generic `Box` class will contain a method with the following signature.

```java
  public void put( final Object item )
```

The child class, `StringBox`, does not have such method.  **How will polymorphism works when generics are used?**

If we list the methods that the `StringBox`, using the `javap` command, we will see that the Java compiler introduces a new method.

```bash
$ javap -p build/classes/java/main/demo/StringBox.class
Compiled from "StringBox.java"
public class demo.StringBox extends demo.Box<java.lang.String> {
  public demo.StringBox();
  public void put(java.lang.String);
  public void put(java.lang.Object);
}
```

The `put()` method is overloaded.  If we analyse the bytecode of the overloaded method (the method generated by the type erasure), will find that it simply casts the input to `String` and calls our method, as shown next.

```
  // access flags 0x1041
  public synthetic bridge put(Ljava/lang/Object;)V
   L0
    LINENUMBER 3 L0
    ALOAD 0
    ALOAD 1
    CHECKCAST java/lang/String
    INVOKEVIRTUAL demo/StringBox.put (Ljava/lang/String;)V
    RETURN
   L1
    LOCALVARIABLE this Ldemo/StringBox; L0 L1 0
    MAXSTACK = 2
    MAXLOCALS = 2
```

The `put()` method, generated by the type erasure, has the following flags.

| Flag Name       | Description                                         |
| --------------- | --------------------------------------------------- |
| `ACC_BRIDGE`    | A bridge method, generated by the compiler.         |
| `ACC_SYNTHETIC` | Declared synthetic; not present in the source code. |

The above table was copied from: [Table 4.6-A. Method access and property flags](https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-4.html#jvms-4.6-200-A.1) in [Chapter 4. The class File Format](https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-4.html) in [The Java® Virtual Machine Specification](https://docs.oracle.com/javase/specs/jvms/se14/html/index.html).

The generated `put()` method is invoking our `put()` as indicated by the [`INVOKEVIRTUAL`](https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-4.html#jvms-4.10.1.9.invokevirtual) bytecode, shown next.

```
    INVOKEVIRTUAL demo/StringBox.put (Ljava/lang/String;)V
```

Type erasure is creating a new method, that simply calls our method while ensuring polymorphism, as shown next.

{% include custom/note.html details="The following is an example of how the code will look like after type erasure."%}

```
package demo;

public class StringBox extends Box<String> {

  public void put( final Object item ) {
    put( (String) item );
  }

  public void put( final String item ) {
    System.out.printf( "Adding string: %s%n", item );
    super.put( item );
  }
}
```

Using this technique, Java is able to support both generics and polymorphism.

### Which version of the method is invoked?

After type erasure, the `StringBox` class will have two methods.

* `put(Object)` method that takes an `Object`
* `put(String)` method that takes a `String`

Both methods are available, and both can be invoked.  Consider the following example.

{% include custom/compile_but_throws.html e="ClassCastException" %}

```java
package demo;

public class App {

  public static void main( final String[] args ) {
    final Box box = new StringBox();
    box.put( Integer.valueOf( 42 ) );
  }
}
```

The above example makes use of raw types.  This means that the compiler will not provide us with type checks, and we can try to put anything we want our box.  The above example fails at runtime with a [`ClassCastException`](https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/ClassCastException.html).

```bash
Exception in thread "main" java.lang.ClassCastException: class java.lang.Integer cannot be cast to class java.lang.String (java.lang.Integer and java.lang.String are in module java.base of loader 'bootstrap')
	at demo.StringBox.put(StringBox.java:3)
	at demo.App.main(App.java:7)
```

The Java runtime environment tried to type cast our value to a `String` and failed as this was an `Integer`.

Now consider the following example that too makes use of raw types.

```java
package demo;

public class App {

  public static void main( final String[] args ) {
    final Object item = "Ball";
    final Box box = new StringBox();
    box.put( item );
  }
}
```

In this example, we are calling the `put()` that takes an `Object` (as the variable `item` is of type `Object` despite the fact that it is pointing to a `String`).  This will type cast the given reference to `String` and then calls the `put()` method that takes a `String`, as shown next.

![Raw Types]({{ '/assets/images/Raw-Types-Generics-Call-1.png' | absolute_url }})

When using raw types we can access the `put()` method that takes a `String` directly too by passing a `String`, as shown next.

```java
package demo;

public class App {

  public static void main( final String[] args ) {
    final Box box = new StringBox();
    box.put( "Ball" );
  }
}
```

Despite the fact that this does not use generics, it still accesses our `put()` method.

Inheritance adds complexity to generics.  Consider the following example.

```java
package demo;

public class Box<T> {

  private T item;

  public void put( final T item ) { /* ... */ }

  public void clear() {
    put( null );
  }
}
```

A new method, named `clear()`, is added to the `Box` class which simply invokes `put()` and passes `null`.  Now consider the following example.

```java
package demo;

public class App {

  public static void main( final String[] args ) {
    final Box<String> box = new StringBox();
    box.clear();
  }
}
```

The `clear()` method invokes the `put()` method that takes an `Object`.  The subtype, `StringBox`, has its own of `put()` method that overrides the `put()` method in the `Box` class.  This method was generated by the type erasure.  The generated method calls our method `put()` that takes a `String`, which calls the parent's method as shown next.

![Raw Types]({{ '/assets/images/Raw-Types-Generics-Call-2.png' | absolute_url }})

## How does type erasure effect return types?

So far we only placed items in our `Box` generic type.  Let's add a new method to the `Box` class that returns the item in the box, as shown next.

```java
package demo;

public class Box<T> {

  private T item;

  public void put( final T item ) { /* ... */ }

  public T get() {
    return item;
  }

  public void clear() { /* ... */ }
}
```

```java
package demo;

public class App {

  public static void main( final String[] args ) {
    final Box<String> box = new StringBox();
    box.put( "Bicycle" );

    final String item = box.get();
    System.out.printf( "The box contains a: %s%n", item );
  }
}
```

```
  // access flags 0x1
  // signature ()TT;
  // declaration: T get()
  public get()Ljava/lang/Object;
   L0
    LINENUMBER 12 L0
    ALOAD 0
    GETFIELD demo/Box.item : Ljava/lang/Object;
    ARETURN
   L1
    LOCALVARIABLE this Ldemo/Box; L0 L1 0
    // signature Ldemo/Box<TT;>;
    // declaration: this extends demo.Box<T>
    MAXSTACK = 1
    MAXLOCALS = 1
```

```
   L2
    LINENUMBER 9 L2
    ALOAD 1
    INVOKEVIRTUAL demo/Box.get ()Ljava/lang/Object;
    CHECKCAST java/lang/String
    ASTORE 2
```

## Covariant return types

```java
package demo;

public class Supertype {

  public Object getIt() {
    return "The supertype";
  }
}
```

```java
package demo;

public class Subtype extends Supertype {

  @Override
  public Object getIt() {
    return "It's me, the subtype";
  }
}
```

```java
package demo;

public class Subtype extends Supertype {

  @Override
  public String getIt() {
    return "It's me, the subtype";
  }
}
```

```
$ javap -p build/classes/java/main/demo/Subtype.class
Compiled from "Subtype.java"
public class demo.Subtype extends demo.Supertype {
  public demo.Subtype();
  public java.lang.String getIt();
  public java.lang.Object getIt();
}
```

```
  // access flags 0x1041
  public synthetic bridge getIt()Ljava/lang/Object;
   L0
    LINENUMBER 3 L0
    ALOAD 0
    INVOKEVIRTUAL demo/Subtype.getIt ()Ljava/lang/String;
    ARETURN
   L1
    LOCALVARIABLE this Ldemo/Subtype; L0 L1 0
    MAXSTACK = 1
    MAXLOCALS = 1
```

`NoSuchMethodError`

## How does type erasure effect return types?

```java
package demo;

public interface Worker<T> {
  T produce();
}
```

```java
package demo;

public class PiWorker implements Worker<Double> {
  @Override
  public Double produce() {
    return Math.PI;
  }
}
```

```bash
$ javap build/classes/java/main/demo/PiWorker.class
```

```bash
Compiled from "PiWorker.java"
public class demo.PiWorker implements demo.Worker<java.lang.Double> {
  public demo.PiWorker();
  public java.lang.Double produce();
  public java.lang.Object produce();
}
```

```
// class version 58.65535 (-65478)
// access flags 0x21
// signature Ljava/lang/Object;Ldemo/Worker<Ljava/lang/Double;>;
// declaration: demo/PiWorker implements demo.Worker<java.lang.Double>
public class demo/PiWorker implements demo/Worker {

  // compiled from: PiWorker.java

  // access flags 0x1
  public <init>()V
   L0
    LINENUMBER 3 L0
    ALOAD 0
    INVOKESPECIAL java/lang/Object.<init> ()V
    RETURN
   L1
    LOCALVARIABLE this Ldemo/PiWorker; L0 L1 0
    MAXSTACK = 1
    MAXLOCALS = 1

  // access flags 0x1
  public produce()Ljava/lang/Double;
   L0
    LINENUMBER 6 L0
    LDC 3.141592653589793
    INVOKESTATIC java/lang/Double.valueOf (D)Ljava/lang/Double;
    ARETURN
   L1
    LOCALVARIABLE this Ldemo/PiWorker; L0 L1 0
    MAXSTACK = 2
    MAXLOCALS = 1

  // access flags 0x1041
  public synthetic bridge produce()Ljava/lang/Object;
   L0
    LINENUMBER 3 L0
    ALOAD 0
    INVOKEVIRTUAL demo/PiWorker.produce ()Ljava/lang/Double;
    ARETURN
   L1
    LOCALVARIABLE this Ldemo/PiWorker; L0 L1 0
    MAXSTACK = 1
    MAXLOCALS = 1
}
```

Some generic information is retained for linking purposes, otherwise the compiler will not be able to determine whether this is the correct generic.

## Are there cases where we cannot use generics?

There are a few minor exceptions to the rule that you should not use raw types. You must use raw types in class literals. The specification does not permit the use of parameterized types (though it does permit array types and primitive types) [JLS, 15.8.2]. In other words, List.class, String[].class, and int.class are all legal, but List<String>.class and List<?>.class are not.

A second exception to the rule concerns the instanceof operator. Because generic type information is erased at runtime, it is illegal to use the instanceof operator on parameterized types other than unbounded wildcard types. The use of unbounded wildcard types in place of raw types does not affect the behavior of the instanceof operator in any way. In this case, the angle brackets and question marks are just noise. This is the preferred way to use the instanceof operator with generic types:
