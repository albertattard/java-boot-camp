---
layout: default
title: Type Erasure
parent: Generics
nav_order: 7
permalink: docs/generics/erasure/
---

# Type Erasure
{: .no_toc }

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## What is type erasure?

Generics came late to the language (Java 1.5) and was implemented in a way that it is still compatible to code that does not use generics ([raw types]({{ '/docs/generics/raw-types/' | absolute_url }})).  [Type Erasure](https://docs.oracle.com/javase/tutorial/java/generics/erasure.html) is the process, happens at the compile time, that makes sure of this.  Type Erasure performs three things:

* Replace all type parameters in generic types with their upper bounds.  `<T>` is replaced by `Object`, which `<T super Xyz>`
* Insert type casts if necessary to preserve type safety.
* Generate bridge methods to preserve polymorphism in extended generic types.


```java
package demo;

public interface Consumer<T> {
  void consume( T t );
}
```

```java
package demo;

public class DoubleConsumer implements Consumer<Double> {
  @Override
  public void consume( final Double value ) {
    System.out.printf( "Double %f%n", value );
  }

  public void consume( final Long value ) {
    System.out.printf( "Long %d%n", value );
  }

  public void consume( final Object value ) {
    System.out.printf( "Object %s%n", value );
  }
}
```


```java
package demo;

public interface Worker<T> {
  T produce();
}
```


```java
package demo;

public class PiWorker implements Worker<Double> {
  @Override
  public Double produce() {
    return Math.PI;
  }
}
```

```bash
$ javap build/classes/java/main/demo/PiWorker.class
```

```bash
Compiled from "PiWorker.java"
public class demo.PiWorker implements demo.Worker<java.lang.Double> {
  public demo.PiWorker();
  public java.lang.Double produce();
  public java.lang.Object produce();
}
```

```
// class version 58.65535 (-65478)
// access flags 0x21
// signature Ljava/lang/Object;Ldemo/Worker<Ljava/lang/Double;>;
// declaration: demo/PiWorker implements demo.Worker<java.lang.Double>
public class demo/PiWorker implements demo/Worker {

  // compiled from: PiWorker.java

  // access flags 0x1
  public <init>()V
   L0
    LINENUMBER 3 L0
    ALOAD 0
    INVOKESPECIAL java/lang/Object.<init> ()V
    RETURN
   L1
    LOCALVARIABLE this Ldemo/PiWorker; L0 L1 0
    MAXSTACK = 1
    MAXLOCALS = 1

  // access flags 0x1
  public produce()Ljava/lang/Double;
   L0
    LINENUMBER 6 L0
    LDC 3.141592653589793
    INVOKESTATIC java/lang/Double.valueOf (D)Ljava/lang/Double;
    ARETURN
   L1
    LOCALVARIABLE this Ldemo/PiWorker; L0 L1 0
    MAXSTACK = 2
    MAXLOCALS = 1

  // access flags 0x1041
  public synthetic bridge produce()Ljava/lang/Object;
   L0
    LINENUMBER 3 L0
    ALOAD 0
    INVOKEVIRTUAL demo/PiWorker.produce ()Ljava/lang/Double;
    ARETURN
   L1
    LOCALVARIABLE this Ldemo/PiWorker; L0 L1 0
    MAXSTACK = 1
    MAXLOCALS = 1
}
```


```
  public produce()Ljava/lang/Double;
```

```
  public synthetic bridge produce()Ljava/lang/Object;
```

| Flag Name       | Description                                         |
| --------------- | --------------------------------------------------- |
| `ACC_BRIDGE`    | A bridge method, generated by the compiler.         |
| `ACC_SYNTHETIC` | Declared synthetic; not present in the source code. | 

[Table 4.6-A. Method access and property flags](https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-4.html#jvms-4.6-200-A.1)

```
    INVOKEVIRTUAL demo/PiWorker.produce ()Ljava/lang/Double;
```

[`INVOKEVIRTUAL`](https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-4.html#jvms-4.10.1.9.invokevirtual)


```java
package demo;

public interface Consumer<T> {
  void consume( T t );
}
```

```java
package demo;

public class DoubleConsumer implements Consumer<Double> {
  @Override
  public void consume( final Double value ) {
    System.out.printf( "Received %f%n", value );
  }
}
```

```bash
$ javap build/classes/java/main/demo/DoubleConsumer.class
```

```bash
Compiled from "DoubleConsumer.java"
public class demo.DoubleConsumer implements demo.Consumer<java.lang.Double> {
  public demo.DoubleConsumer();
  public void consume(java.lang.Double);
  public void consume(java.lang.Object);
}
```


## Type Erasure

Are not 100% Erased

```java
package java.util.concurrent;

@FunctionalInterface
public interface Callable<V> {

    V call() throws Exception;
}
```

```java
package demo;

import java.util.concurrent.Callable;

public class PiCallable implements Callable<Double> {

  @Override
  public Double call() {
    return Math.PI;
  }
}
```

```bash
$ ./gradlew clean build
```

```bash
$ javap build/classes/java/main/demo/PiCallable.class

Compiled from "PiCallable.java"
public class demo.PiCallable implements java.util.concurrent.Callable<java.lang.Double> {
  public demo.PiCallable();
  public java.lang.Double call();
  public java.lang.Object call() throws java.lang.Exception;
}
```

Some generic information is retained for linking purposes, otherwise the compiler will not be able to determine whether this is the correct generic.

```java
public void readDouble(Callable<Double> callable) { /* ... */ }
```

Generics need to be backward compatible and need to support raw types.  That's why we have two versions of the `call()` method.

```java
public void linkToRawType(Callable callable) { /* ... */ }
```
